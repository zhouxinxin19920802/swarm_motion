<!DOCTYPE HTML>
<html>

<head>

	<title>Vicsek Model Simulation</title>
	<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro">
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		/* to remove the top and left whitespace */
		html,
		body {
			width: 100%;
			height: 100%;
			overflow: hidden
		}

		/* just to be sure these are full screen*/
		canvas {
			display: block;
		}

		body {
			font-family: 'Source Sans Pro', 'Arial';
			font-size: 24px;
		}

		div {
			height: 100%;
			background-color: #708090;
		}
	</style>
</head>

<body>
	<div style="position: relative;">
		<canvas id="layer1" width="3000" height="3000" style="position: absolute; left: 0; top: 0; z-index: 0;">
		</canvas>
	</div>

	<script>
		// Setup canvas
		var canvas = document.getElementById('layer1');
		var ctx = canvas.getContext('2d');
		//取消此处注释,可以让绘图区与浏览器窗口一样大
		// ctx.canvas.width  = window.innerWidth ;
		// ctx.canvas.height = window.innerHeight;
		//取消此处注释,可以重置绘图区的尺寸, 会覆盖canvas静态尺寸
		// ctx.canvas.width  = 500;
		// ctx.canvas.height = 250;
		ctx.fillStyle = "#FFFFFF";

		// zxx:添加移动
		window.addEventListener("load", function () {
			// var canvas = document.getElementById("myCanvas");
			// var ctx = canvas.getContext("2d");

			// // 绘制一些内容
			// ctx.fillStyle = "red";
			// ctx.fillRect(50, 50, 100, 100);

			var isDragging = false;
			var startX, startY;
			var translateX = 0;
			var translateY = 0;

			canvas.addEventListener("mousedown", function (event) {
				isDragging = true;
				startX = event.clientX;
				startY = event.clientY;
				console.log("start_x_y:", startX, startY);
			});

			canvas.addEventListener("mousemove", function (event) {
				if (isDragging) {
					var deltaX = event.clientX - startX;
					var deltaY = event.clientY - startY;
					startX = event.clientX;
					startY = event.clientY;
					translateX += deltaX;
					translateY += deltaY;
					// 应用平移变换
					canvas.style.transform = "translate(" + translateX + "px, " + translateY + "px)";
				}
			});

			canvas.addEventListener("mouseup", function () {
				isDragging = false;
			});
		});

		function getURLParameter(name) {
			return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search) || [, ""])[1].replace(/\+/g, '%20')) || null
		}

		var downindex;//population中的数组下标
		// Simulation configuration (spatial unit is always pixel)
		var config = {
			body_size: getURLParameter('bs') || 3, // Radius of the circle representing each individual每个粒子自身半径
			tail_size: getURLParameter('ts') || 20, // Size of the velocity line representing direction of movement表示运动方向的速度线大小
			pbody_size: getURLParameter('pbs') || 3, // 捕食者自身半径
			ptail_size: getURLParameter('pts') || 10, // 表示捕食者运动方向的速度线大小
			tail_width: getURLParameter('bw') || 2, // Thickness of the tail速度线的厚度
			N: getURLParameter('N') || 20, // Size of population粒子总数
			N_p: getURLParameter('N_p') || 1, // 捕食者总数
			velocity: getURLParameter('v') || 2, // Default velocity in pixels per update粒子速度
			p_velocity: getURLParameter('p_v') || 0.33, // 捕食者速度
			deltaT: 1, // We use a fixed step这是什么？
			noise_amplitude: getURLParameter('n') || 0.0, // 噪声
			noise_amplitude1: getURLParameter('n1') || 0, // 随机攻击噪声
			noise_amplitude2: getURLParameter('n2') || 0, // 恶意攻击噪声
			neighborhood_radius: getURLParameter('r') || 60, // 通信半径
			neighborhood_k: getURLParameter('k') || 1000,//连接的邻居数
			neighborhood_radius_rep: getURLParameter('r_rep') || 10, //排斥半径
			neighborhood_radius_align: getURLParameter('r_rep') | 60, //对齐半径
			fps: getURLParameter('fps') || 5000, // Animation's Frames per second动画每秒帧数
			blur: getURLParameter('blur') || 0.6, // Amount of blur from 0.0 to 1.0模糊量？？？
			att_r: getURLParameter('r_att') || 50,//捕食者危险区域半径  
			p_informd: getURLParameter('p_informd') || 0.1,//知情比例   		
			p: getURLParameter('p') || 0,//攻击比例 
			px: getURLParameter('px') || 0,//首选方向横坐标 
			py: getURLParameter('py') || 0,//首选方向纵坐标  
			Sps: getURLParameter('Stime') || 10,//采样间隔  s
			L1: getURLParameter('L1') || 1000,//群体最初出现的边界	
			rf: getURLParameter('rf') || 200,//目标地点半径	
			T: getURLParameter('T') || 2500,//仿真总时长	
			Location: getURLParameter('Location') || 2,//"1"选择前面粒子做leader；“2”选择后面粒子做leader; "3"选择中间粒子做Leader；"4"选择左侧粒子做Leader；；"5"选择右侧粒子做Leader
		}
		//config.px=(Math.random()+5)/6*ctx.canvas.width;
		//config.py=Math.random()*ctx.canvas.height;
		var r1 = 30, r2 = 35, r3 = 40; //划分多状态空间

		config.r_squared = Math.pow(config.neighborhood_radius, 2)
		config.L = Math.sqrt(config.N / config.denn);
		//选择目的地位置
		//config.xf=(Math.random()+5)/6*ctx.canvas.width;
		config.xf = 2200;
		config.yf = 1500;
		//config.yf=Math.random()*ctx.canvas.height;
		// Uniform noise from -eta/2 to eta/2
		function noise(eta) {
			return (2 * Math.random() - 1) * eta / 2 * Math.PI;
		}

		// A class to keep track of each individual state. As the speed is
		// constant, we need only the velocity angle to full specify the velocity
		// vector and we call it theta

		//邻居共同作用的方向向量
		var neiborx;
		var neibory;
		var nflock = 0;//子群个数
		var networkarr2 = [];//二维数组，存储t时刻网络
		for (var i = 0; i < config.N; i++)//
		{
			networkarr2[i] = new Array();
			for (var j = 0; j < config.N; j++)
				networkarr2[i][j] = "-1";
		}
		var networkarr3 = [];
		for (var i = 0; i <= config.T; i++)//
		{
			networkarr3[i] = new Array();
			for (var j = 0; j < config.N; j++) {
				networkarr3[i][j] = new Array();
				for (var k = 0; k < config.N; k++)
					networkarr3[i][j][k] = 0;
			}
		}





		var multinetwork3 = [];//三维数组，存储多状态网络
		for (var i = 0; i < config.N; i++)//
		{
			multinetwork3[i] = new Array();
			for (var j = 0; j < config.N; j++) {
				multinetwork3[i][j] = new Array();
				multinetwork3[i][j][0] = 0;
				multinetwork3[i][j][1] = 0;
				multinetwork3[i][j][2] = 0;
				multinetwork3[i][j][3] = 0;
				multinetwork3[i][j][4] = 0;
			}
		}




		//把每时刻网络dij复制到networkarr中
		//邻居列表应该跟每个个体关联，所有应该是在这个位置加
		function Individual(x, y, theta, index, sign, w, sign_informed, flock) {
			this.x = x;
			this.y = y;
			this.theta = theta;
			this.index = index;
			this.sign = sign;
			this.w = w;
			this.sign_informed = sign_informed;
			this.box = [Math.floor(this.x / config.neighborhood_radius), Math.floor(this.y / config.neighborhood_radius)];//box是一个数组，指的是什么
			this.flock = flock;//群号
			this.neigh = new Array();//邻居集合
			this.ttheta = theta;//邻居集合

			// Compute the Euclidean distance from this individual to another
			this.distance_squared = function (individual) {
				return Math.pow(this.x - individual.x, 2) + Math.pow(this.y - individual.y, 2);
			};
			//计算朝着目标位置移动的方向向量	
			this.direction_focus = function () {
				var yff = config.yf - this.y;
				var xff = config.xf - this.x;
				config.px = xff / Math.sqrt(Math.pow(xff, 2) + Math.pow(yff, 2));
				config.py = yff / Math.sqrt(Math.pow(xff, 2) + Math.pow(yff, 2));

			};

			//冒泡排序
			this.distance_sort = function (dij, s) {
				for (var x = 0; x < s - 1; x++) {
					for (var y = 0; y < s - x - 1; y++) {
						if (dij[y][0] > dij[y + 1][0]) {
							var temp0 = dij[y][0];
							var temp1 = dij[y][1];
							dij[y][0] = dij[y + 1][0];
							dij[y][1] = dij[y + 1][1];
							dij[y + 1][0] = temp0;
							dij[y + 1][1] = temp1;
						}
					}
				}

			};

			//Draw this individual
			this.draw = function () {

				// Draw circle
				if (this.sign == 1 && if_attack == 1) {
					ctx.beginPath();
					ctx.arc(this.x, this.y, config.body_size, 0, 2 * Math.PI, false);
					ctx.lineWidth = config.tail_width;
					ctx.strokeStyle = "#FF0000";
					ctx.fillStyle = "#FF0000";
					ctx.fill();
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(this.x - config.body_size * Math.cos(this.theta), this.y - config.body_size * Math.sin(this.theta));
					ctx.lineTo(this.x - config.tail_size * Math.cos(this.theta), this.y - config.tail_size * Math.sin(this.theta));
					ctx.lineWidth = config.tail_width;
					ctx.strokeStyle = "#FF0000";
					ctx.stroke();
				}
				else if (this.sign_informed == 1) {
					ctx.beginPath();
					ctx.arc(this.x, this.y, config.body_size, 0, 2 * Math.PI, false);
					ctx.lineWidth = config.tail_width;
					ctx.strokeStyle = "#FF0000";
					ctx.fillStyle = "#FF0000";
					ctx.fill();
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(this.x - config.body_size * Math.cos(this.theta), this.y - config.body_size * Math.sin(this.theta));
					ctx.lineTo(this.x - config.tail_size * Math.cos(this.theta), this.y - config.tail_size * Math.sin(this.theta));
					ctx.lineWidth = config.tail_width;
					ctx.strokeStyle = "#FF0000";
					ctx.stroke();
				}
				else {
					ctx.beginPath();
					ctx.arc(this.x, this.y, config.body_size, 0, 2 * Math.PI, false);
					ctx.lineWidth = config.tail_width;
					ctx.strokeStyle = "#006400";
					ctx.fillStyle = "#006400";
					ctx.fill();
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(this.x - config.body_size * Math.cos(this.theta), this.y - config.body_size * Math.sin(this.theta));
					ctx.lineTo(this.x - config.tail_size * Math.cos(this.theta), this.y - config.tail_size * Math.sin(this.theta));
					ctx.lineWidth = config.tail_width;
					ctx.strokeStyle = "#006400";
					ctx.fillStyle = "#006400";
					ctx.fill();
					ctx.stroke();
				}
			}

			this.neighbors_theta = function (boxes) {
				// Compute average theta in the neighborhood
				var neighbors_theta = 0.0;
				var neighbors_theta1 = 0.0;
				var neighbors_theta2 = 0.0;
				var neighbors_theta3 = 0.0;
				var neighbors_theta33 = 0.0;
				var neighbors_theta41 = 0.0;
				var neighbors_theta42 = 0.0;
				var count_neighbors = 0;
				var neighbors_theta5 = 0.0;
				var neighbors_theta6 = 0.0;
				var neighbors_theta71 = 0.0;
				var neighbors_theta72 = 0.0;
				var neighbors_theta7 = 0.0;
				var neighbors_theta8 = 0.0;
				var neighbors_theta81 = 0.0;//sin
				var neighbors_theta82 = 0.0;//cos
		
	

				var rij = 0;

				//index_att=0,未执行对齐和吸引；index_att=1；执行了对齐和吸引
				var att = 0;
				//index_asp=0,未执行排斥；index_att=1；执行了排斥
				var rsp = 0;
				var this_individual = this;

				// Get this individual's box
				box_i = this.box[0]
				box_j = this.box[1]
				// console.log("box_i_j:",box_i,box_j);
				var e = 0;
				var s = 0;
				var vji = 0;
				var vjcos = 0;
				var vjsin = 0;
				var nvji = [];
				var mvji = 0;
				var mvjik = 0;

				var totoavij = 0;


				var dij = [];//二维数组，存储邻居及距离
				for (var i = 0; i < config.N; i++){
					dij[i] = new Array();
					dij[i][0] = "";
					dij[i][1] = "";
				}



				for (var i = box_i - 1; i <= box_i + 1; i++) {
					//只看该粒子周围2*2个盒子的粒子是不是有邻居
					if (i < 0 || i > ctx.canvas.width / config.neighborhood_radius) {
						// console.log("zhixing");
						continue;
					}
					for (var j = box_j - 1; j <= box_j + 1; j++) {
						if (j < 0 || j > ctx.canvas.height / config.neighborhood_radius) {
							continue;
						}

						boxes[i][j].forEach(function (individual) {
							rij = this_individual.distance_squared(individual);

							var x1 = Math.cos(this_individual.theta);
							var y1 = Math.sin(this_individual.theta);
							var x2 = individual.x - this_individual.x;
							var y2 = individual.y - this_individual.y;

							//调整可见角度
							if ((Math.pow(x2, 2) + Math.pow(y2, 2)) > 0) {
								//通过angle角判断邻居是否位于目标个体前方
								var angle = Math.acos((x1 * x2 + y1 * y2) / Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
							}
							//th1判断运动方向是否一致
							//两个粒子运动方向之间的夹角，夹角越大，方向差异越大，交互能见角越大
							var th1 = Math.cos(this_individual.theta - individual.theta)   
							var angle1 = Math.PI*3/2;
							if (rij <= config.r_squared && angle < angle1) {
								var k1;
								var k2;
								//无知个体要求判断邻居是否在可视角内
								if (this_individual.sign_informed == 0) {//在通信半径里 
									//存储个体之间的距离的平方
									dij[s][0] = rij;
									dij[s][1] = individual;
									k1 = this_individual.index;
									k2 = individual.index;
									// zxx: 存储两两节点的距离
									//networkarr2存储当前时刻的邻接矩阵
									networkarr2[k1][k2] = Math.sqrt(rij);
									s++;
								}
								if (this_individual.sign_informed == 1) {
									//知情个体为全向可视角
									dij[s][0] = rij;//存储个体之间的距离
									dij[s][1] = individual;//存储邻居
									k1 = this_individual.index;
									k2 = individual.index;
									networkarr2[k1][k2] = Math.sqrt(rij);//networkarr2存储当前时刻的邻接矩阵
									s++;
								}

							}

						})
					}
				}
				// console.log("dij:",dij);
				// console.log("s:",s)
				this_individual.direction_focus();
				var K = config.neighborhood_k;

				//如果粒子到达目的地，则只有目的地的吸引，不再受其他力
				// console.log("neighbors_theta41_42_first",neighbors_theta41,neighbors_theta42,s);


				/* zxx:这里三个判断,1.是否在终点范围内,2.是否有邻居 3.其它,也就是无邻居,并为每个范围内的速度方向做好准备.
				1. 在终点范围内更新速度方向.
				2. 在对齐范围内,更新速度方向和排斥、对齐标志,rsp,arr, 81为角度,71为排斥, 3和33为对齐, 41为本智能体速度.
				3. 通讯范围内,没其它节点就本速度.
				*/
				// 在终点范围内
				if (Math.pow(this.x - config.xf, 2) + Math.pow(this.y - config.yf, 2) <= Math.pow(config.neighborhood_radius_align, 2)) {
					// console.log("config_px_py",config.px,config.py);
					neighbors_theta41 += config.py;
					neighbors_theta42 += config.px;
				}
				// zxx: s是从0开始的,所以邻居的数量s>0,邻居就不止一个
				else if (s - 1 > 0) {
					// console.log("running");
					this.distance_sort(dij, s);
					//地理距离+拓扑双重约束邻居数量 
					// zxx: 邻居的数量应该是s+1,因为数量是s+1
					if (s + 1 < K) {
						// zxx:更新k
						K = s - 1;
					}
					// zxx:vjcos和vjsin后面都没用
					//最近的k个邻居互联
					// ============================================
					for (var k = 0; k <= K; k++) {
						//所有邻居的平均速度
						vjcos += Math.cos(dij[k][1].theta);
						vjsin += Math.sin(dij[k][1].theta);
						this_individual.neigh[k] = dij[k][1].index;
					}
					vjcos = vjcos / (K + 1);
					vjsin = vjsin / (K + 1);
				


                    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					//记录群号
					// zxx:找到最大群号
					var fmin = config.N + 1;

					for (var k = 0; k <= K; k++) {
						if (dij[k][1].flock != 0) {
							if (fmin > dij[k][1].flock) {
								fmin = dij[k][1].flock;
							}
						}
					}
					// console.log("fmin_after:",fmin);
					// // zxx: 展示各个节点的flock
					// flock_set = []
					// for(var i = 0 ; i< population.length ; i++ ){
					// 	flock_set.push(population[i].flock);
					// }
					// console.log("flock_set_ing1:",flock_set);

					// zxx: 邻居个体的编号都更新为fmin
					if (fmin != config.N + 1) {
						// console.log("KKKKKKKKKKKKKKKKK");
						var i;
						for (var k = 0; k <= K; k++) {
							i = dij[k][1].index;
							population[i].flock = fmin;
						}
						// zxx: 展示各个节点的flock
						flock_set = []
						for (var i = 0; i < population.length; i++) {
							flock_set.push(population[i].flock);
						}
					}
					else {
						nflock++;
						var i;
						for (var k = 0; k <= K; k++) {
							i = dij[k][1].index;
							population[i].flock = nflock;
						}

						// zxx: 展示各个节点的flock
						flock_set = []
						for (var i = 0; i < population.length; i++) {
							flock_set.push(population[i].flock);
						}
					}
                    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



					//如果存在邻居

					for (var k = 0; k <= K; k++) {

						//处在通信半径中的邻居之间画线连接
						this_individual.neigh[e] = dij[k][1].index;
						e++;

						count_neighbors += 1;

						//排斥
						//sign为2，说明与失效节点相连	
						// zxx: 判断是否在排斥范围内,以及邻居不是本节点
						if (dij[k][0] <= Math.pow(config.neighborhood_radius_rep, 2) && this_individual.index != dij[k][1].index) {
							if ((dij[k][1].sign == 1 && if_attack == 1 && this_individual.sign == 0) || dij[k][1].sign == 2) {
								this_individual.sign = 2;
							}
							//sin
							neighbors_theta71 += (this_individual.y - dij[k][1].y) / Math.sqrt(dij[k][0]);
							//cos
							neighbors_theta72 += (this_individual.x - dij[k][1].x) / Math.sqrt(dij[k][0]);
							rsp = 1;
						}

						//聚集和对齐在一个环里
						if ((dij[k][0] > Math.pow(config.neighborhood_radius_rep, 2) && dij[k][0] <= Math.pow(config.neighborhood_radius, 2)) || this_individual.index == dij[k][1].index) { //对齐
							if ((dij[k][1].sign == 1 && if_attack == 1 && this_individual.sign == 0) || dij[k][1].sign == 2) { this_individual.sign = 2; }
							// console.log("neighbors_theta41_42_two__before",neighbors_theta41,neighbors_theta42,dij[k][1].sign,if_attack);
							// zxx:如果没有打击，自身也不是被破坏的点,也没发生打击
							if (!(dij[k][1].sign == 1 && if_attack == 1)) {
								neighbors_theta41 += Math.sin(dij[k][1].theta);
								neighbors_theta42 += Math.cos(dij[k][1].theta);
							}
							// console.log("neighbors_theta41_42_two__after",neighbors_theta41,neighbors_theta42);
							//聚集
							if (this_individual.index != dij[k][1].index) {
								neighbors_theta3 += (dij[k][1].y - this_individual.y) / Math.sqrt(dij[k][0]);
								neighbors_theta33 += (dij[k][1].x - this_individual.x) / Math.sqrt(dij[k][0]);
								att = 1;
							}

						}
					}
					this_individual.neigh[K] = 1000;
				}
				// zxx: 这个邻居是感知范围内的邻居
				//如果没有邻居
				else {
					neighbors_theta41 = Math.sin(this_individual.theta);
					neighbors_theta42 = Math.cos(this_individual.theta);
					// console.log("neighbors_theta41_42_two__2",neighbors_theta41,neighbors_theta42);
				}
				//距离太近，只有斥力
				if (rsp == 1){
					neighbors_theta81 = neighbors_theta71;
					neighbors_theta82 = neighbors_theta72;
				}
				else {
					// zxx:对齐
					// console.log("neighbors_theta41_42_three",neighbors_theta41,neighbors_theta42);
					// zxx: 当感知范围内没有节点时,neighbors_theta3和neighbors_theta33为0.
					neighbors_theta81 = neighbors_theta41 + neighbors_theta3;
					neighbors_theta82 = neighbors_theta42 + neighbors_theta33;
				}
				if (neighbors_theta81 == 0 && neighbors_theta82 == 0) {
					neighbors_theta81 = Math.sin(this_individual.theta);
					neighbors_theta82 = Math.cos(this_individual.theta);
				}
				// neighbors_theta1和2是新更新的
				neighbors_theta1 = neighbors_theta81 / Math.sqrt(Math.pow(neighbors_theta81, 2) + Math.pow(neighbors_theta82, 2));
				neighbors_theta2 = neighbors_theta82 / Math.sqrt(Math.pow(neighbors_theta81, 2) + Math.pow(neighbors_theta82, 2));

				//知情个体
				//zxx:距离终点在对齐范围内
				if (Math.pow(this.x - config.xf, 2) + Math.pow(this.y - config.yf, 2) > Math.pow(config.neighborhood_radius_align, 2)) {
					if ((this_individual.sign_informed == 1 && !(this_individual.sign == 1 && if_attack == 1)) || Math.pow((config.yf - this_individual.y), 2) + Math.pow((config.xf - this_individual.x), 2) <= Math.pow(config.rf, 2)) {
						
						// if (s - 1 > 0) {
						// 	// 知情者w的更新
						// 	var neiX = 0, neiY = 0;//记录邻居的平均位置
						// 	var nei_d; //记录知情者与邻居之间的距离
						// 	for (var k = 1; k <= K; k++) {
						// 		neiX += dij[k][1].x;
						// 		neiY += dij[k][1].y;
						// 	}
						// 	nei_d = Math.sqrt(Math.pow((this_individual.x - neiX / K), 2), Math.pow((this_individual.y - neiY / K), 2));
						// 	this_individual.w = Math.exp((config.N / 25) * (-nei_d / config.neighborhood_radius));

						// }
						// else {
						// 	this_individual.w = 1;
						// }
						this.w = 1;
						neighbors_theta1 += this_individual.w * config.py;
						neighbors_theta2 += this_individual.w * config.px;
						/*neighbors_theta1+=1*config.py;
						neighbors_theta2 +=1*config.px;*/
					}
				}

				// 又回到81和82了
				neighbors_theta81 = neighbors_theta1 / Math.sqrt(Math.pow(neighbors_theta1, 2) + Math.pow(neighbors_theta2, 2));
				neighbors_theta82 = neighbors_theta2 / Math.sqrt(Math.pow(neighbors_theta1, 2) + Math.pow(neighbors_theta2, 2));

				neibory = neighbors_theta81;
				neiborx = neighbors_theta82;

				if (!(neighbors_theta81 == 0 && neighbors_theta82 == 0)) {
					// zxx: 记住81是y, 82是x
					if (neighbors_theta81 < 0 && neighbors_theta82 < 0) {
						neighbors_theta = Math.atan(neighbors_theta81 / neighbors_theta82) - Math.PI;
					}
					else if (neighbors_theta81 > 0 && neighbors_theta82 < 0) {
						neighbors_theta = Math.atan(neighbors_theta81 / neighbors_theta82) + Math.PI;
					}
					else {
						neighbors_theta = Math.atan(neighbors_theta81 / neighbors_theta82);
					}
				}
				if (isNaN(neighbors_theta))
					alert("0");


				return neighbors_theta;


			}


			// Update this individual according to Vicsek rules. We need to pass an
			// array of individuals, as we use neighbors information to compute the
			// average direction in the individual neighborhood
			//更新角度
			this.update = function (boxes) {
				if (this.sign == 1 && if_attack == 1) {
					this.theta = this.theta;
				}
				else {
					var rr = this.neighbors_theta(boxes) + noise(config.noise_amplitude);
					var qq = rr - this.theta;

					if (qq > Math.PI) {
						if ((2 * Math.PI - qq) > 2 * (1 / 5)) {
							neighbors_theta = this.theta - 2 * (1 / 5);
						}
						else {
							neighbors_theta = rr;
						}
					}
					if (qq < -Math.PI) {
						if ((2 * Math.PI + qq) > 2 * (1 / 5)) {
							neighbors_theta = this.theta + 2 * (1 / 5);
						}
						else {
							neighbors_theta = rr;
						}
					}
					if (Math.abs(qq) >= 0 && Math.abs(qq) <= 2 * (1 / 5)) {
						neighbors_theta = rr;
					}
					if (Math.abs(qq) > 2 * (1 / 5) && Math.abs(qq) <= Math.PI) {
						neighbors_theta = this.theta + 2 * (1 / 5) * (Math.abs(qq) / qq);
					}

					this.ttheta = this.theta;

					this.theta = neighbors_theta;
				}

				if (this.sign == 1 && if_attack == 1) {
					this.x = this.x;
					this.y = this.y;

				}



				else {
					this.x = this.x + config.velocity * config.deltaT * Math.cos(this.theta);
					this.y = this.y + config.velocity * config.deltaT * Math.sin(this.theta);
				}

				// Apply periodic boundary condition (torus)
				if (this.x < 0) {
					this.x += ctx.canvas.width
				}
				if (this.x > ctx.canvas.width) {
					this.x -= ctx.canvas.width
				}
				if (this.y < 0) {
					this.y += ctx.canvas.height
				}
				if (this.y > ctx.canvas.height) {
					this.y -= ctx.canvas.height
				}



				// Update box
				this.box[0] = Math.floor(this.x / config.neighborhood_radius);
				this.box[1] = Math.floor(this.y / config.neighborhood_radius);

			}
		};

		// Randomly create a population of N individuals
		//创建生物, 如果要减少生物数量, 把population数据出栈就可以
		function create(N) {
			var population = [];
			population.push(new Individual(config.L1 / 4, ctx.canvas.height / 2, (2 * Math.random() - 1) * Math.PI, 0, 0, 0.0, 0, 0));
			//population.push(new Individual(config.xf,config.yf,(2*Math.random() - 1)*Math.PI,0,0,0));
			for (var i = 1; i < N; i++) {
				var ic = Math.floor(population.length * Math.random());
				var xi = (2 * Math.random() - 1) * config.neighborhood_radius + population[ic].x;
				var yi = (2 * Math.random() - 1) * config.neighborhood_radius + population[ic].y;
				var ri1 = Math.sqrt(Math.pow(xi - population[ic].x, 2) + Math.pow(yi - population[ic].y, 2));
				while (ri1 > config.neighborhood_radius) {
					var xi = (2 * Math.random() - 1) * config.neighborhood_radius + population[ic].x;
					var yi = (2 * Math.random() - 1) * config.neighborhood_radius + population[ic].y;
					var ri1 = Math.sqrt(Math.pow(xi - population[ic].x, 2) + Math.pow(yi - population[ic].y, 2));
				}
				population.push(new Individual(xi, yi, (2 * Math.random() - 1) * Math.PI, i, 0, 0, 0, 0));
			};

			return population;
		}


		function update_boxes(population) {
			var max_i = Math.floor(ctx.canvas.width / config.neighborhood_radius);
			var max_j = Math.floor(ctx.canvas.height / config.neighborhood_radius);

			// Initialize boxes lists (boxes[i][j] = []) to get indices later
			var boxes = [];
			for (var i = 0; i <= max_i; i++) {
				boxes.push([]);
				for (var j = 0; j <= max_j; j++) {
					boxes[i].push([]);
				}
			}
			// Push each individual in population to it's proper box
			population.forEach(function (individual) {
				boxes[individual.box[0]][individual.box[1]].push(individual);
			});

			return boxes;
		}


		// Generate population
		var population = create(config.N);



		// Put initial individuals is their boxes
		var boxes = update_boxes(population);

		// Update all individuals
		function update() {
			// flock_swarm = [];
			// console.log("population:", population, population.length);
			for (i = 0; i < population.length; i++) {
				population[i].flock = 0;
				// zxx: 复制一个群组，因为对象是地址，防止进行 
				// // console.log("ITEM:", i, population[i]);

				// flock_swarm.push(new individual_flock(population[i].x, population[i].y, population[i].index, population[i].sign_informed));

			}
			nflock = 0;

			// console.log("item_flock0:",flock_swarm[0],flock_swarm[1]);
			// console.log("item_flock1:",flock_swarm);

			// cons_flock = calcluster(flock_swarm);

			// console.log("cons_flock:", cons_flock.length);

			// // 找到包含领导者的群，并找到集群规模最大的群
			// var subswarm_set = [];
			// for (var k = 0; k < cons_flock.length; k++) {

			// 	for (var i = 0; i < population.length; i++) {

			// 		if (population[i].sign_informed == 1) {

			// 			for (var j = 0; j < cons_flock[k].length; j++) {

			// 				if (cons_flock[k][j].index == population[i].index) {
			// 					break;
			// 				}
			// 			}
			// 			subswarm_set.push(cons_flock[k]);
			// 			break;
			// 		}
			// 	}
			// }

			// // console.log("subswarm_set_length:", subswarm_set.length);

			// var swarm_connectity = 0;
			// for (var l = 0; l < subswarm_set.length; l++) {
			// 	// console.log(" subswarm_set[l].length:", subswarm_set[l].length);
			// 	var subswarm_length = subswarm_set[l].length;
			// 	if (subswarm_length != 1) {
			// 		swarm_connectity = swarm_connectity + subswarm_length / (subswarm_length * (subswarm_length - 1));
			// 	}
			// }
			// // console.log("swarm_connectity:", swarm_connectity)
			// test.Writeline(swarm_connectity);

			population.forEach(function (individual) {
				individual.update(boxes);
			});



			// zxx: 展示各个节点的flock
			// Update boxes lists
			boxes = update_boxes(population);
		};


		// Draw moving individuals
		function draw() {
			// 画布
			ctx.globalAlpha = 1 - config.blur;//当前透明值
			ctx.fillStyle = "#FFFFFF";
			ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);//填充一个矩形fillRect（矩阵左上角的横坐标、纵坐标、矩阵的宽、高）
			//sctx.globalAlpha = 1.0;

			// 小圈
			ctx.beginPath();
			ctx.arc(config.xf, config.yf, 10, 0 * Math.PI, 2 * Math.PI, true);
			ctx.fillStyle = "#FF0000";
			ctx.fill();
			ctx.stroke();
			// 大圈
			ctx.beginPath();
			ctx.arc(config.xf, config.yf, config.rf, 0 * Math.PI, 2 * Math.PI, false);
			ctx.lineWidth = 3;
			ctx.strokeStyle = "#FF0000";
			ctx.stroke();


			//ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			population.forEach(function (individual) {
				individual.draw();
			});


		}
		function sleep(d) {
			for (var t = Date.now(); Date.now() - t <= d;);
		}
		//随机选择多个数组元素  
		/*function getRandomArrayElements(arr, count) {
		var shuffled = arr.slice(0), i = arr.length, min = i - count, temp, index;
		while (i-- > min) {
			index = Math.floor((i + 1) * Math.random());
			temp = shuffled[index];
			shuffled[index] = shuffled[i];
			shuffled[i] = temp;
		}
		return shuffled.slice(min);
		}*/
		var signinf = [];
		signattc = [];

		//随机选领导者
		function getRandomArrayInformed(count) {
			var i = population.length, min = i - count, index;
			while (i-- > min) {
				index = Math.floor(population.length * Math.random());
				for (var j = 0; j < signinf.length; j++) {
					if (index == signinf[j]) {
						index = Math.floor(population.length * Math.random());
						j = -1;
						continue;
					}
				}
				signinf[population.length - i - 1] = index;
				population[index].sign_informed = 1;
			}
		}

		// 按最大度选择领导者
		function getDegreeArrayInformed(count) {
			var kneigh = [];
			for (var i = 0; i < population.length; i++) {
				kneigh[i] = new Array();
				kneigh[i][0] = "";
				kneigh[i][1] = "";
			}
			var index;
			for (var i = 0; i < population.length; i++) {
				kneigh[i][0] = population[i].neigh.length;
				kneigh[i][1] = i;
			}

			for (var x = 0; x < population.length; x++) {
				for (var y = 0; y < population.length - x - 1; y++) {
					if (kneigh[y][0] > kneigh[y + 1][0]) {
						var temp0 = kneigh[y][0];
						var temp1 = kneigh[y][1];
						kneigh[y][0] = kneigh[y + 1][0];
						kneigh[y][1] = kneigh[y + 1][1];
						kneigh[y + 1][0] = temp0;
						kneigh[y + 1][1] = temp1;
					}

				}
			}

			for (var j = population.length - 1; j > population.length - 1 - count; j--) {
				index = kneigh[j][1];
				signinf[population.length - j - 1] = index;
				population[index].sign_informed = 1;
			}

		}

		//按最大流选择领导者
		function getFlowArrayInformed(count) {
			var Flownetwork = [];
			var sum = [];
			for (var i = 0; i < population.length; i++) {
				Flownetwork[i] = new Array();
				for (var j = 0; j < population.length; j++) {
					if (networkarr2[i][j] == -1 || networkarr2[i][j] == 0)
						Flownetwork[i][j] = 0;
					else if (networkarr2[i][j] <= r1)
						Flownetwork[i][j] = 3;
					else if (networkarr2[i][j] <= r2)
						Flownetwork[i][j] = 2;
					else if (networkarr2[i][j] <= r3)
						Flownetwork[i][j] = 1;
					else
						Flownetwork[i][j] = 0;
				}

			}

			for (var i = 0; i < population.length; i++) {
				sum[i] = 0;
				for (var j = 0; j < population.length; j++)
					sum[i] = sum[i] + Flownetwork[i][j];
			}

			for (var x = 0; x < population.length - 1; x++) {
				for (var y = 0; y < population.length - x - 1; y++) {
					if (sum[y] > sum[y + 1]) {
						var temp0 = sum[y];
						var temp1 = population[y];
						sum[y] = sum[y + 1];
						population[y] = population[y + 1];
						sum[y + 1] = temp0;
						population[y + 1] = temp1;
					}
				}
			}

			for (var i = 0; i < count; i++) {

				var k = population.length - 1;
				signinf[i] = population[k - i].index;
				population[k - i].sign_informed = 1;
			}
		}







		//按地理位置选领导者

		//Location=1,选择前面粒子做leader, Locaiton=2,选择后面粒子做Leader；Location=3,选择中间粒子做Leader;
		//Location=4,选择左侧粒子做Leader;Location=5,选择右侧粒子做Leader;

		function getLocationArrayInformed(count) {

			if (config.Location == 1 || config.Location == 2) {
				for (var x = 0; x < population.length - 1; x++) {
					for (var y = 0; y < population.length - x - 1; y++) {
						if (population[y].x > population[y + 1].x) {
							var temp0 = population[y];
							population[y] = population[y + 1];
							population[y + 1] = temp0;
						}
					}
				}

				if (config.Location == 1)
					for (var i = 0; i < count; i++) {
						var k = population.length - 1;
						signinf[i] = population[k - i].index;
						population[k - i].sign_informed = 1;
					}
				//Location=1,选择前面粒子做leader, Locaiton=2,选择后面粒子做Leader；Location=3,选择中间粒子做Leader
				if (config.Location == 2)
					for (var i = 0; i < count; i++) {

						signinf[i] = population[i].index;
						population[i].sign_informed = 1;
					}
			}


			if (config.Location == 4 || config.Location == 5) {
				for (var x = 0; x < population.length - 1; x++) {
					for (var y = 0; y < population.length - x - 1; y++) {
						if (population[y].y > population[y + 1].y) {
							var temp0 = population[y];
							population[y] = population[y + 1];
							population[y + 1] = temp0;
						}
					}
				}

				if (config.Location == 5)
					for (var i = 0; i < count; i++) {
						var k = population.length - 1;
						signinf[i] = population[k - i].index;
						population[k - i].sign_informed = 1;
					}

				if (config.Location == 4)
					for (var i = 0; i < count; i++) {

						signinf[i] = population[i].index;
						population[i].sign_informed = 1;
					}
			}










			if (config.Location == 3) {
				var ax = 0, ay = 0;
				for (var i = 0; i < population.length; i++) {
					ax = ax + population[i].x;
					ay = ay + population[i].y;
				}
				ax = ax / population.length;
				ay = ay / population.length;

				for (var x = 0; x < population.length - 1; x++) {
					for (var y = 0; y < population.length - x - 1; y++) {
						var ady = Math.pow(population[y].x - ax, 2) + Math.pow(population[y].y - ay, 2);
						var ady1 = Math.pow(population[y + 1].x - ax, 2) + Math.pow(population[y + 1].y - ay, 2);
						if (ady > ady1) {
							var temp0 = population[y];
							population[y] = population[y + 1];
							population[y + 1] = temp0;
						}
					}
				}

				for (var i = 0; i < count; i++) {

					signinf[i] = population[i].index;
					population[i].sign_informed = 1;
				}


			}


		}



		function getRandomArrayIndex(count) {
			var i = population.length, min = i - count, index;
			while (i-- > min) {
				index = Math.floor(population.length * Math.random());
				for (var j = 0; j < signattc.length; j++) {
					if (index == signattc[j]) {
						index = Math.floor(population.length * Math.random());
						j = -1;
						continue;
					}
				}
				signattc[population.length - i - 1] = index;
				population[index].sign = 1;
			}
		}

		function individual_flock(x, y, index, sign_informed) {
			this.x = x;
			this.y = y;
			this.index = index;
			this.sign_informed = sign_informed
		}

		function isAlladjacentnodesvisited(temp1, layer, ls) {

			for (var i = 0; i < layer.length; i++) {
				var item;
				item = layer[i];


				adjacentnodes1 = findAdjacentnodes(item, ls);

				for (var j = 0; j < adjacentnodes1.length; j++) {
					item1 = adjacentnodes1[j];
					var cons = false;
					for (var k = 0; k < temp1.length; k++) {
						if (item1.index == temp1[k].index) {
							cons = true;
						}
					}
					if (cons == false) {
						return false;
					}
				}
			}
			return true;
		}


		function findAdjacentnodes(node, agentset) {
			var adjacentnodes2;
			adjacentnodes2 = [];
			for (var i = 0; i < agentset.length; i++) {
				var item;
				item = agentset[i];
				if (node.index != item.index) {
					if (isconnected(node, item)) {
						adjacentnodes2.push(item);
					}
				}
			}
			return adjacentnodes2;
		}

		function isconnected(a1, a2) {
			if (Math.sqrt((a1.x - a2.x) * (a1.x - a2.x) + (a1.y - a2.y) * (a1.y - a2.y)) <= config.neighborhood_radius) {
				return true;
			}
			return false;
		}

		function isIn(node, nodeset) {
			for (var i = 0; i < nodeset.length; i++) {
				if (node.index == nodeset[i].index) {
					return true;
				}
			}
			return false;
		}


		function calcluster(ls) {
			cons = [];

			while (ls.length != 0) {

				// 获取第一个点
				var temp;
				temp = ls[0];

				// 将第一个点放入集合
				var temp1;
				temp1 = [temp];
				// 存储邻居集合
				var adjacentnodes;
				adjacentnodes = [temp];




				// temp:已经访问过的节点， adjacentnodes:最新层的所有邻居节点

				while (isAlladjacentnodesvisited(temp1, adjacentnodes, ls) == false) {

					var adjacentnodes_temp;
					adjacentnodes_temp = [];
					for (var i = 0; i < adjacentnodes.length; i++) {
						var tempNeibour;
						tempNeibour = adjacentnodes[i];

						var adjacentnodes3;
						adjacentnodes3 = findAdjacentnodes(tempNeibour, ls);

						for (j = 0; j < adjacentnodes3.length; j++) {
							node = adjacentnodes3[j];
							if (isIn(node, temp1)) {
								continue;
							}
							// 把此节点加入到已经访问的节点中
							temp1.push(node);
							// 把此节点加入到邻居节点中区
							adjacentnodes_temp.push(node);
						}
					}
					adjacentnodes = adjacentnodes_temp;
				}

				cons.push(temp1);
				// 在ls中奖所有temp中
				for (var k = 0; k < ls.length; k++) {
					for (var m = 0; m < temp1.length; m++) {
						if (ls[k].index == temp1[m].index) {
							ls.splice(k--, 1);
							break
						}
					}
				}
			}

			return cons;
		}




		/**
		  *定义消失的时间步长和消失个数变量, 这些都是全局变量
		  *下面两个变量用来控制攻击规则, 你可以通过修改这两个值, 来定义规则
		**/
		//打击周期时间, 单位是ms, 1000ms=1s.
		//var killDuration = 1000;
		//每次攻击的粒子总数
		//var killNumbers = 0.2*population.length;
		//
		//var dead =0;

		//不要修改这个变量, 这个临时变量用来保存每个打击周期是否到来
		//var durationTemp = 0;


		var insin;
		var incos;
		var box_ia;
		var box_ja;



		var population1 = create(1); //生成捕食者


		// 程序开始的入口
		var time_attack = 0;
		var if_attack = 0;//0:未开始攻击；1：攻击

		var t_p = 0;
		var flag1 = 0;
		var flag2 = 0;
		var firstnum = 0;


		window.onload = function () {
			console.log("starting");
			var num = 0;
			var num1 = 0;
			var num2 = 0;
			var t_eat = 0;
			var Va = 0;
			var Va1 = 0;
			var Ava = 0;
			var C = 0;
			var C1 = 0;
			var C2 = 0;
			var total_sintheta = 0;
			var total_costheta = 0;
			var total_mulV = 0;
			var mulV = 0;

			var temp_sin = 0;
			var temp_cos = 0;
			var dip = [];//粒子与捕食者之间距离
			var tdip = 0;
			var dipt = [];
			var tdipt = 0;
			var ccx1 = [];//记录本次采样时的x坐标
			var ccy1 = [];//记录本次采样时的y坐标
			var ccx0 = [];//记录上一次采样时的x坐标
			var ccy0 = [];//记录上一次采样时的y坐标
			var theta0 = [];//记录上一次采样时的方向角
			var theta1 = [];//记录本次采样时的方向角

			var AvaX0 = 0;
			var AvaX1 = 0;
			var AvaY0 = 0;
			var AvaY1 = 0;
			var AvaY = 0;
			var AvaY = 0;
			var Cgd;//同Couzin运动方向
			var AvaX00 = 0;
			var AvaX11 = 0;
			var AvaY00 = 0;
			var AvaY11 = 0;
			var AvaYY = 0;
			var AvaYY = 0;
			var sCgd;
			for (var i = 0; i < population.length; i++) {
				ccx0[i] = population[i].x;
				ccy0[i] = population[i].y;
				ccx1[i] = 0;
				ccy1[i] = 0;
			}
			var standP = Math.sqrt(Math.pow(config.px * config.Sps * config.velocity, 2) + Math.pow(config.py * config.Sps * config.velocity, 2));//首选方向上的标准位移
			getRandomArrayInformed(config.N * 0.2);

			// // zxx: 展示各个节点的flock
			// flock_set = []
			// for(var i = 0 ; i< population.length ; i++ ){
			// 	flock_set.push(population[i].flock);
			// }
			// console.log("flock_set:",flock_set);

			// 连通度
			var fso = new ActiveXObject("Scripting.FileSystemObject");
			if (fso.FileExists("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\swarm_connectity.txt")) {
				test = fso.OpenTextFile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\swarm_connectity.txt", 8, false);
			}
			else {
				test = fso.createtextfile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\swarm_connectity.txt", 8, false);
			}

			// 平均空间相关度
			var fso = new ActiveXObject("Scripting.FileSystemObject");
			if (fso.FileExists("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\spatial_correlation.txt")) {
				fDegreeSpace = fso.OpenTextFile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\spatial_correlation.txt", 8, false);
			}
			else {
				fDegreeSpace = fso.createtextfile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\spatial_correlation.txt", 8, false);
			}

			// 平均时间依赖程度
			var fso_time = new ActiveXObject("Scripting.FileSystemObject");    
			if (fso_time.FileExists("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\average_time_dependence.txt")) {
				var fDegreeTime = fso_time.OpenTextFile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\average_time_dependence.txt", 8, false);
			}
			else{
				var fDegreeTime = fso_time.createtextfile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\average_time_dependence.txt", 8, false);
			}

			//到达率
			//到达的不知情个体个数
			if (fso.FileExists("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\follower_agents_agents.txt")){
				var fcountnof = fso.OpenTextFile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\follower_agents_agents.txt", 8, false);
			}
			else{
				var fcountnof = fso.createtextfile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\follower_agents_agents.txt", 8, false);
			}
			//到达的知情个体个数
			if (fso.FileExists("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\informed_agents.txt")){
				var fcountinf = fso.OpenTextFile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\informed_agents.txt", 8, false);
			}
			else{
				var fcountinf = fso.createtextfile("E:\\zhouxin\\swarm_motion\\swarm_motion_couzin\\data\\informed_agents.txt", 8, false);
			}

			// fbound0.Writeline("hha");
			// fbound0.close();
			// //存储攻击初始时刻被困住的个数
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-bound0.txt")) {
			// 	var fbound0 = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-bound0.txt", 8, false);
			// }
			// else
			// 	var fbound0 = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-bound0.txt", 8, false);
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-Cgd.txt")) {
			// 	var fgd = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-Cgd.txt", 8, false);
			// }
			// else
			// 	var fgd = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-Cgd.txt", 8, false);

			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-Clongx.txt")) {
			// 	var flongx = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-Clongx.txt", 8, false);
			// }
			// else
			// 	var flongx = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-Clongx.txt", 8, false);
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-Cgds.txt")) {
			// 	var fgds = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-Cgds.txt", 8, false);
			// }
			// else
			// 	var fgds = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-Cgds.txt", 8, false);

			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-Clongxs.txt")) {
			// 	var flongxs = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-Clongxs.txt", 8, false);
			// }
			// else
			// 	var flongxs = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-Clongxs.txt", 8, false);
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-Countnof.txt"))//到达的不知情个体个数
			// {
			// 	var fcountnof = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-Countnof.txt", 8, false);
			// }
			// else
			// 	var fcountnof = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-Countnof.txt", 8, false);
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-Countinf.txt"))//到达的知情个体个数
			// {
			// 	var fcountinf = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-Countinf.txt", 8, false);
			// }
			// else
			// 	var fcountinf = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-Countinf.txt", 8, false);

			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-fT.txt")) {
			// 	var fT = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-fT.txt", 8, false);
			// }
			// else
			// 	var fT = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-fT.txt", 8, false);


	

			// //平均相对速度 -  向量差的长度
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-fRelSpeed.txt")) {
			// 	var fRelSpeed = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-fRelSpeed.txt", 8, false);
			// }
			// else {
			// 	var fRelSpeed = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-fRelSpeed.txt", 8, false);
			// }

			// //自适应w值  
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-fw.txt")) {
			// 	var fw = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-fw.txt", 8, false);
			// }
			// else
			// 	var fw = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-fw.txt", 8, false);

			// //只考虑知情个体所在子群的连通可靠性
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-flock.txt")) {
			// 	var fflock = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-flock.txt", 8, false);
			// }
			// else
			// 	var fflock = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-flock.txt", 8, false);

			// //记录最大群的规模
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-fmax.txt")) {
			// 	var ffmax = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-fmax.txt", 8, false);
			// }
			// else
			// 	var ffmax = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-fmax.txt", 8, false);

			// //记录邻接矩阵
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-fnetwork.txt")) {
			// 	var fnetwork = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-fnetwork.txt", 8, false);
			// }
			// else
			// 	var fnetwork = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-fnetwork.txt", 8, false);

			// //记录状态分布
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-fdistribute.txt")) {
			// 	var fdistribute = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-fdistribute.txt", 8, false);
			// }
			// else
			// 	var fdistribute = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-fdistribute.txt", 8, false);

			// //记录知情个体
			// if (fso.FileExists("c:\\simulation\\N100pinf0.1a=1-Random-fleader.txt")) {
			// 	var fleader = fso.OpenTextFile("c:\\simulation\\N100pinf0.1a=1-Random-fleader.txt", 8, false);
			// }
			// else
			// 	var fleader = fso.createtextfile("c:\\simulation\\N100pinf0.1a=1-Random-fleader.txt", 8, false);




			//setInterval,是个刷新方法, 刷新频率为:1000/config.fps(程序自己配置的默认值是1s50帧)
			//console.log(population[1]);

			var DegSpace = 0, dflag1 = 0, dflag2 = 0, RelSpeed = 0, dflag3 = 0, DegTime = 0;





			setInterval(function () {
				//每次刷新清空networkarr2
				for (var i = 0; i < config.N; i++)//
				{
					networkarr2[i] = new Array();
					for (var j = 0; j < config.N; j++)
						networkarr2[i][j] = -1;
				}
				// console.log(networkarr2);
				update();
				draw();



				var count_infn = 0;
				var count_nofn = 0;
				var count_fn = 0;
				var test1 = 0, test2 = 0;

				Va1 = 0;
				total_sintheta = 0;
				total_costheta = 0;
				//将网络信息存入networkarr3和multinetwork3




				// zxx: 在100step之后，而且还没有个体到达终点之前，存储两个节点之间关系。
				if (num >= 100 && flag1 != 1) {
					for (var i = 0; i < config.N; i++) {
						for (var j = 0; j < config.N; j++) {
							networkarr3[num][i][j] = networkarr2[i][j];
						}
					}
				}

				if (flag1 == 1 || (flag1 == 0 && num == config.T - 1)) {
					if (flag2 != 1) {
						for (var t = 100; t < firstnum; t++)
							for (var i = 0; i < population.length; i++)
								for (var j = 0; j < population.length; j++) {
									// console.log("distance:", networkarr3[t][i][j]);
									if (networkarr3[t][i][j] == -1 || networkarr3[t][i][j] == 0)

										multinetwork3[i][j][0]++;
									else if (networkarr3[t][i][j] <= r1)
										multinetwork3[i][j][3]++;
									else if (networkarr3[t][i][j] <= r2)
										multinetwork3[i][j][2]++;
									else if (networkarr3[t][i][j] <= r3)
										multinetwork3[i][j][1]++;
									else
										multinetwork3[i][j][0]++;

								}
						flag2 = 1;//标志已经存入过multinetwork3
					}
				}

				// 输出一个邻接矩阵，一个状态分布表，一个leader列表

				// if (num == config.T - 1) {
				// 	for (var i = 0; i < population.length; i++)
				// 		for (var j = 0; j < population.length; j++) {
				// 			multinetwork3[i][j][0] = multinetwork3[i][j][0] / (firstnum - 100);
				// 			// 如果状态0的概率大于0.95，就认为是1.即不存在边
				// 			if (multinetwork3[i][j][0] >= 0.95) {

				// 				multinetwork3[i][j][0] = 1;
				// 				for (var k = 1; k <= 3; k++) {
				// 					multinetwork3[i][j][k] = 0;
				// 				}
				// 			}
				// 			else {	//判断i和j之间的边是否相连，如果相连，则	multinetwork3[i][j][0]=1
				// 				multinetwork3[i][j][4] = 1;
				// 				for (var k = 1; k <= 3; k++) {
				// 					multinetwork3[i][j][k] = multinetwork3[i][j][k] / (firstnum - 100);
				// 				}
				// 			}
				// 		}
				// 	for (var i = 0; i < population.length; i++) {
				// 		for (var j = 0; j < population.length; j++) {
				// 			// fnetwork.Write(multinetwork3[i][j][4] + '	');
				// 			if (multinetwork3[i][j][0] != 1) {
				// 				// fdistribute.Write(i + '&' + j + '	' + multinetwork3[i][j][0] + '	' + multinetwork3[i][j][1] + '	' + multinetwork3[i][j][2] + '	' + multinetwork3[i][j][3]);
				// 				// fdistribute.Writeline();
				// 			}

				// 		}
				// 		// fnetwork.Writeline();
				// 	}

				// 	for (var i = 0; i < signinf.length; i++){
				// 		// fleader.write(signinf[i] + '	');
				// 	}
				// 	// console.log(signinf);

				// }
		





				//记录第一个达到目的地的时间
				if (flag1 != 1) {

					for (var i = 0; i < population.length; i++) {
						if (Math.pow((config.yf - population[i].y), 2) + Math.pow((config.xf - population[i].x), 2) <= Math.pow(config.rf, 2)) {

							count_fn++;
							// console.log("count_fn:", count_fn);

						}
					}
				}
				// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
				//输出到达目的地的知情者和无知者个数
				// 师姐最大连通子群指标有问题。
				var fsize = new Array();
				if (num > 0 && num % 50 == 0) {    
					//  记录w
					// for(var i=0;i<population.length;i++){
					// 	  if(population[i].sign_informed==1)
					// 			// fw.Writeline(population[i].w);
					// 			console.log("w",(population[i].w));
					// }
					for (var j = 1; j <= nflock; j++) {
						fsize[j] = 0;
					}
					//表征知情个体所在群号是否相同1：不同；0：相同
					var findex = 1;
					var f_att = [];
					var j_att = 0;

					//记录各个群里agent的个数
					for (var j = 1; j <= nflock; j++) {
						for (var l = 0; l < population.length; l++) {
							if (population[l].flock == j) {
								fsize[j]++;
							}
						}
					}


					var con = 0;//计算连通性
					var fmax = 0;//记录最大群规模

					for (var i = 1; i <= nflock; i++)
						if (fsize[i] != 0) {
							con += fsize[i] * (fsize[i] - 1) / 2;
							if (fsize[i] > fmax)
								fmax = fsize[i];
						}
					con = con / (config.N * (config.N - 1) / 2);
					// fflock.Writeline(con);
					// ffmax.Writeline(fmax);
					// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					//zxx: 每50个step计算一次集群连通度
					flock_swarm = [];
					// console.log("population:", population, population.length);
					for (i = 0; i < population.length; i++) {
						population[i].flock = 0;
						// zxx: 复制一个群组，因为对象是地址，防止进行 
						// console.log("ITEM:", i, population[i]);
						flock_swarm.push(new individual_flock(population[i].x, population[i].y, population[i].index, population[i].sign_informed));

					}
					nflock = 0;
					cons_flock = calcluster(flock_swarm);
					// 找到包含领导者的群，并找到集群规模最大的群
					var subswarm_set = [];
					for (var k = 0; k < cons_flock.length; k++) {
						for (var i = 0; i < population.length; i++) {
							if (population[i].sign_informed == 1) {
								for (var j = 0; j < cons_flock[k].length; j++) {
									if (cons_flock[k][j].index == population[i].index) {
										break;
									}
								}
								subswarm_set.push(cons_flock[k]);
								break;
							}
						}
					}
					// console.log("subswarm_set_length:", subswarm_set.length);
					var swarm_connectity = 0;
					for (var l = 0; l < subswarm_set.length; l++) {
						var subswarm_length = subswarm_set[l].length;
						if (subswarm_length != 1) {
							swarm_connectity = swarm_connectity + subswarm_length * (subswarm_length - 1);
						}
					}
					console.log("swarm_connectity:", swarm_connectity);
					swarm_connectity = swarm_connectity / (population.length * (population.length - 1));
					console.log("swarm_connectity1:", population.length * (population.length - 1));
					// console.log("swarm_connectity:", swarm_connectity)
					test.Writeline(swarm_connectity);
				}






				if (num == 0) {
					for (var i = 0; i < population.length; i++) {
						AvaX0 += population[i].x;
						AvaY0 += population[i].y;
						ccx0[i] = population[i].x;
						ccy0[i] = population[i].y;
						theta0[i] = population[i].theta;
					}
					AvaX0 = AvaX0 / population.length;
					AvaY0 = AvaY0 / population.length;

					AvaX00 = AvaX0;
					AvaY00 = AvaY0;
				}






				if (num > 0 && num % 50 == 0) {
					for (var i = 0; i < population.length; i++) {
						AvaX1 += population[i].x;
						AvaY1 += population[i].y;
						ccx1[i] = population[i].x;
						ccy1[i] = population[i].y;
						// zxx:cxx0,ccy0初始的，平均x，y位置
						var cx = ccx1[i] - ccx0[i];
						var cy = ccy1[i] - ccy0[i];
						// C2+=population[i].x; 
						// zxx:  这可能存在一个bug,这config.px,config.py每个个体都会更新，这个config.px,config.py是最后一个个体的

						C1 += (cx * config.px + cy * config.py) / (50 * config.velocity);
						//C+=Math.cos(population[i].theta)*config.px+Math.sin(population[i].theta)*config.py;	
						// zxx: 50个步长更新一次
						ccx0[i] = ccx1[i];
						ccy0[i] = ccy1[i];

						theta1[i] = population[i].theta;
						test3 = Math.cos(population[i].theta) * Math.cos(theta0[i]) + Math.sin(population[i].theta) * Math.sin(theta0[i]);
						if (test3 != 0){
							dflag3++;
							DegTime += test3;
						}
						theta0[i] = theta1[i];


						for (var j = i + 1; j < population.length; j++) {
							//计算平均空间依赖程度
							//zxx:各个个体之间的夹角
							test1 = Math.cos(population[i].theta) * Math.cos(population[j].theta) + Math.sin(population[i].theta) * Math.sin(population[j].theta);
							if (test1 != 0) {
								dflag1++;
								DegSpace += test1;
							}
							//计算平均相对速度
							// zxx:横纵方向速度差平方和的开方
							test2 = Math.sqrt(Math.pow(Math.cos(population[i].theta) - Math.cos(population[j].theta), 2) + Math.pow(Math.sin(population[i].theta) - Math.sin(population[j].theta), 2));
							if (test2 != 0){
								dflag2++;
							    RelSpeed += test2;
							}
						}

					}

					// zxx: 平均速度变化
					C1 = C1 / population.length;
					// zxx:平均横纵坐标位置
					AvaX1 = AvaX1 / population.length;
					AvaY1 = AvaY1 / population.length;

					AvaX = AvaX1 - AvaX0;
					AvaY = AvaY1 - AvaY0;

					// f1.Writeline(C1);
					//求夹角cos值，只是角度，没有移动速度
					Cgd = (AvaX * (config.xf - AvaX0) + AvaY * (config.yf - AvaY0)) / (Math.sqrt(Math.pow(AvaX, 2) + Math.pow(AvaY, 2)) * Math.sqrt(Math.pow(config.xf - AvaX0, 2) + Math.pow(config.yf - AvaY0, 2)));
					AvaX0 = AvaX1;
					AvaY0 = AvaY1;

					//    //alert(""+Cgd);
					// fgd.Writeline(Cgd);
					//沿x轴方向移动位移
					// flongx.Writeline(AvaX / (50 * config.velocity));


					AvaX1 = 0;
					AvaY1 = 0;

				}

				// 仅在未有智能体到达终点时候，才计算平均空间依赖度和平均时间依赖度
				if ((count_fn > 0 && flag1 != 1)) {
					//记录平均空间依赖程度
					DegSpace = DegSpace / dflag1;
					fDegreeSpace.Writeline(DegSpace);

					// 相对速度
					RelSpeed = RelSpeed / dflag2;
					// fRelSpeed.Writeline(RelSpeed);

					// 平均时间相关性
					DegTime = DegTime / dflag3;
					fDegreeTime.Writeline(DegTime);

				}


				// zxx: count_fn在每个时间间隔里会被初始为0，一旦有节点到达终点后，count_fn就不会更新了
				if ((count_fn > 0 && flag1 != 1) || num == config.T - 2) {
					// fT.Writeline(num);
					if (firstnum == 0) {
						firstnum = num;
					}
					// zxx: 判断第几个step有第一个点到达终点
					flag1 = 1;
				}


				// 对应第四个指标，到达率
				if (num == config.T) {
					for (var i = 0; i < population.length; i++)
						if (Math.pow((config.yf - population[i].y), 2) + Math.pow((config.xf - population[i].x), 2) <= Math.pow(config.rf, 2)) {
							if (population[i].sign_informed == 1) {
								// 领导者数量
								count_infn++;
							}
							else {
								// 非领导者数量
								count_nofn++;
							}
							count_fn++;
						}
					// zxx:判断结束时，到达终点时的领导者数量和非领导者数量
					fcountinf.Writeline(count_infn);
					fcountnof.Writeline(count_nofn);
				}






				//若发生了攻击，被攻击粒子不再计算指标
				// if (num > 0 && num % 50 == 0) {
				// 	var num0 = 0;//记录没有收到攻击和被锚定的个体的中心

				// 	for (var i = 0; i < population.length; i++) {
				// 		if (!(population[i].sign == 1 && if_attack == 1) && !(population[i].sign == 2 && if_attack == 1)) {
				// 			AvaX11 += population[i].x;
				// 			AvaY11 += population[i].y;
				// 			num0++;
				// 		}
				// 	}
				// 	AvaX11 = AvaX11 / num0;
				// 	AvaY11 = AvaY11 / num0;

				// 	AvaXX = AvaX11 - AvaX00;
				// 	AvaYY = AvaY11 - AvaY00;

				// 	//求夹角cos值，只是角度，没有移动速度
				// 	sCgd = (AvaXX * (config.xf - AvaX00) + AvaYY * (config.yf - AvaY00)) / (Math.sqrt(Math.pow(AvaXX, 2) + Math.pow(AvaYY, 2)) * Math.sqrt(Math.pow(config.xf - AvaX00, 2) + Math.pow(config.yf - AvaY00, 2)));
				// 	//求移动位移
				// 	AvaX00 = AvaX11;
				// 	AvaY00 = AvaY11;
				// 	//    //alert(""+Cgd);
				// 	fgds.Writeline(sCgd);
				// 	//沿x轴方向移动位移
				// 	flongxs.Writeline((Math.sqrt(Math.pow(AvaXX, 2) + Math.pow(AvaYY, 2))) / (50 * config.velocity));
				// 	AvaX11 = 0;
				// 	AvaY11 = 0;


				// }

				// //记录被锚定的个数		
				// if (num >= 1000 && num % 50 == 0) {
				// 	var bound0 = 0;
				// 	for (var i = 0; i < population.length; i++) {
				// 		if (population[i].sign == 2) { bound0++; }

				// 	}
				// 	/*if(num==2000||num==2010||num==5000)
				// 	alert(bound0);*/

				// 	fbound0.Writeline(bound0);
				// }
				// /*if(num==100000)
				// {if_attack=0;}*/


				// if (num == 100 || num == 500 || num == 1000 || flag1 != 0 || num == 2000) {
				// 	var hhhhhr = 0;

				// }




				num++;
		

				if (num == config.T + 1) {
					// if (count_fn == 0)
					// 	fT.Writeline(config.T);

					// fbound0.Writeline();
					// fbound0.close();
					// fgd.Writeline();
					// fgd.close();
					// flongx.Writeline();
					// flongx.close();
					// fgds.Writeline();
					// fgds.close();
					// flongxs.Writeline();
					// flongxs.close();
					// fcountinf.Writeline();
					// fcountinf.close();
					// fcountnof.Writeline();
					// fcountnof.close();
					// fT.Writeline();
					// fT.close();

					// 平均空间相关性
					fDegreeSpace.Writeline();
					fDegreeSpace.close();
                    // 平均时间相关性
					fDegreeTime.Writeline();
					fDegreeTime.close();

					// 追随者到达率
					fcountnof.Writeline();
					fcountnof.close();
					
					// 追随者到达率
					fcountinf.Writeline();
					fcountinf.close();

					// // 平均相对速度
					// fRelSpeed.Writeline();
					// fRelSpeed.close();
					// fw.Writeline();
					// fw.close();
					// fflock.Writeline();
					// fflock.close();
					// ffmax.Writeline();
					// ffmax.close();
					// fdistribute.Writeline();
					// fdistribute.close();
					// fnetwork.Writeline();
					// fnetwork.close();
					// fleader.Writeline();
					// fleader.close();

					// //  fneigh.close();

					test.Writeline();
					test.close();

					window.location.reload(true);
				}

			}, 1000 / config.fps);

		}

	</script>
</body>

</html>